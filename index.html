<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NVlib</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet" />
    <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined" rel="stylesheet" />
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .canvas {
            background-color: #f9fafb;
            border: 1px solid #d1d5db;
            position: relative;
            overflow: hidden;
            background-image:
                linear-gradient(to right, #e5e7eb 1px, transparent 1px),
                linear-gradient(to bottom, #e5e7eb 1px, transparent 1px);
            background-size: 20px 20px;
        }
        .component {
            position: absolute;
            cursor: move;
            border: 1px solid transparent;
            user-select: none;
            font-size: 14px;
            box-sizing: border-box;
        }
        .component.selected {
            outline: 2px solid #2563eb;
            box-shadow: 0 0 10px rgba(59, 130, 246, 0.5);
        }
        
        /* --- LOCKED STATE LOGIC --- */
        .component.locked {
            cursor: not-allowed !important;
        }
        .component.locked .resizer {
            display: none !important;
        }
        .canvas.show-locked-outlines .component.locked {
            outline: 2px dashed #ef4444 !important;
        }

        /* Visual cue during group selection */
        .component.group-selecting {
            outline: 2px solid #10b981 !important; /* Green */
            box-shadow: 0 0 10px rgba(16, 185, 129, 0.5);
        }

        /* Visual cue during alignment target selection */
        .component.align-target-selectable:hover {
            outline: 2px solid #3b82f6 !important; /* Blue */
            box-shadow: 0 0 10px rgba(59, 130, 246, 0.5);
            cursor: pointer !important;
        }
        
        /* NEW: Component border minimization */
        .component-render-wrapper {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            border: none;
            background-color: #fff;
            overflow: hidden;
            box-sizing: border-box;
            position: relative;
        }
        
        /* Minimized borders */
        .component:not(.panel-type):not(.cardview-type):not(.image-type):not(.progressbar-type):not(.hybrid-base) .component-render-wrapper {
            border-top: 1px solid #e5e7eb;
            border-left: 1px solid #e5e7eb;
            border-right: none;
            border-bottom: none;
        }
        
        .component.panel-type .component-render-wrapper,
        .component.cardview-type .component-render-wrapper,
        .component.image-type .component-render-wrapper,
        .component.progressbar-type .component-render-wrapper,
        .component.hybrid-base .component-render-wrapper {
            border: 1px solid #e5e7eb;
        }
        
        /* Hybrid component styling */
        .component.hybrid-base {
            outline: 2px solid #f59e0b !important;
        }
        
        /* Resizer styling */
        .resizer {
            width: 12px;
            height: 12px;
            background: #2563eb;
            border: 2px solid white;
            position: absolute;
            right: -6px;
            bottom: -6px;
            cursor: se-resize;
            z-index: 10;
            border-radius: 2px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        }
        
        .id-error {
            background-color: #fee2e2 !important;
            border-color: #ef4444 !important;
        }
        .material-symbols-outlined {
          font-variation-settings: 'FILL' 0, 'wght' 400, 'GRAD' 0, 'opsz' 24
        }
        .preview-component {
            position: absolute;
            box-sizing: border-box;
        }
        .preview-component input, .preview-component textarea, .preview-component select, .preview-component button {
            width: 100%;
            height: 100%;
            box-sizing: border-box;
            cursor: pointer;
        }
        .preview-button:active {
            transform: scale(0.98);
            filter: brightness(0.95);
        }
        
        /* --- CONTEXT MENU & NESTED SUBMENUS --- */
        #context-menu {
            width: 220px;
        }
        /* Allow nesting: submenu appearing to the right of a submenu item */
        .submenu-container {
            position: relative;
        }
        .submenu-container > .submenu {
            display: none;
            position: absolute;
            left: 100%;
            top: -5px;
            background-color: white;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            border: 1px solid #e5e7eb;
            border-radius: 0.375rem;
            padding-top: 0.25rem;
            padding-bottom: 0.25rem;
            width: 180px;
            z-index: 60;
        }
        .submenu-container:hover > .submenu {
            display: block;
        }
        
        /* --- ALIGNMENT GUIDES --- */
        .guide-line {
            position: absolute;
            background-color: #ec4899; /* Magenta */
            z-index: 9999;
            pointer-events: none;
            display: none;
            box-shadow: 0 0 2px rgba(255, 255, 255, 0.8);
        }
        
        /* --- TOGGLE SWITCH --- */
        .toggle-checkbox:checked {
            right: 0;
            border-color: #68D391;
        }
        .toggle-checkbox:checked + .toggle-label {
            background-color: #68D391;
        }
        
        /* --- FLOATING MENU TRANSITIONS --- */
        #settings-menu {
            transition: opacity 0.2s, transform 0.2s;
            transform-origin: top right;
        }
        #settings-menu.hidden {
            display: none;
        }

        /* --- MARGIN TOOL POPUP --- */
        #margin-tool-popup {
            position: absolute;
            background: white;
            padding: 12px;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.15);
            border: 1px solid #e5e7eb;
            z-index: 100;
            width: 200px;
            display: none;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: #2563eb;
            cursor: pointer;
            margin-top: -6px;
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            background: #e5e7eb;
            border-radius: 2px;
        }

        /* --- FLOATING CONTROLS --- */
        .floating-control-bar {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            padding: 8px 16px;
            border-radius: 24px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
            z-index: 100;
            display: none;
            align-items: center;
            gap: 12px;
        }
        #grouping-control { background: #374151; }
        #alignment-control { background: #2563eb; }
        #attachment-control { background: #8b5cf6; }

        /* --- ATTACHMENT MODE --- */
        .attachment-mode .component.attachment-base {
            outline: 3px solid #8b5cf6 !important;
            box-shadow: 0 0 15px rgba(139, 92, 246, 0.5);
        }
        .attachment-mode .component.attachment-child {
            outline: 2px dashed #8b5cf6 !important;
        }
        
        /* --- LAYER TREE VIEW --- */
        #layer-tree-modal {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.5);
            z-index: 1000;
            display: none;
            align-items: center;
            justify-content: center;
        }
        .layer-tree-container {
            background: white;
            border-radius: 12px;
            width: 400px;
            max-height: 80vh;
            overflow: hidden;
            box-shadow: 0 20px 25px -5px rgba(0,0,0,0.1);
        }
        .layer-tree-header {
            background: #4f46e5;
            color: white;
            padding: 16px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .layer-tree-content {
            padding: 16px;
            overflow-y: auto;
            max-height: 60vh;
        }
        .layer-item {
            padding: 12px;
            margin-bottom: 8px;
            background: #f9fafb;
            border-radius: 8px;
            border: 1px solid #e5e7eb;
            cursor: move;
            display: flex;
            align-items: center;
            gap: 12px;
            transition: all 0.2s;
        }
        .layer-item:hover {
            background: #f3f4f6;
            border-color: #d1d5db;
        }
        .layer-item.dragging {
            opacity: 0.5;
        }
        .layer-item.selected {
            background: #dbeafe;
            border-color: #3b82f6;
        }
        .layer-icon {
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #e5e7eb;
            border-radius: 4px;
            color: #4b5563;
        }
        .layer-children {
            margin-left: 36px;
            margin-top: 4px;
            border-left: 2px solid #e5e7eb;
            padding-left: 12px;
        }
        
        /* --- COMPACT DESIGN MODE --- */
        .compact-mode .component-render-wrapper {
            padding: 0 4px;
        }
        .compact-mode .component:not(.panel-type):not(.cardview-type):not(.image-type):not(.progressbar-type):not(.hybrid-base) .component-render-wrapper span {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800">

    <div class="flex flex-col h-screen">
        <!-- Header -->
        <header class="bg-white shadow-md p-4 flex justify-between items-center z-20">
            <div class="flex items-center gap-4">
                <h1 class="text-2xl font-bold text-gray-800">NVLib v4</h1>
                <button id="layer-tree-btn" class="px-4 py-2 bg-indigo-500 text-white rounded-md hover:bg-indigo-600 flex items-center gap-2">
                    <span class="material-symbols-outlined">layers</span>
                    Layer Tree
                </button>
                <button id="compact-mode-btn" class="px-4 py-2 bg-gray-200 text-gray-700 rounded-md hover:bg-gray-300 flex items-center gap-2">
                    <span class="material-symbols-outlined">crop</span>
                    Compact Mode
                </button>
            </div>
            <div class="flex items-center space-x-4">
                <div class="flex items-center space-x-2">
                    <label for="window-title" class="text-sm font-medium">Window Title:</label>
                    <input type="text" id="window-title" value="My GUI" class="w-48 p-2 border border-gray-300 rounded-md">
                </div>
                <div class="flex items-center space-x-2">
                    <label for="canvas-width" class="text-sm font-medium">Canvas Width:</label>
                    <input type="number" id="canvas-width" value="800" class="w-24 p-2 border border-gray-300 rounded-md">
                    <label for="canvas-height" class="text-sm font-medium">Height:</label>
                    <input type="number" id="canvas-height" value="600" class="w-24 p-2 border border-gray-300 rounded-md">
                    <button id="resize-canvas" class="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700">Resize</button>
                </div>
                <button id="live-preview-btn" class="px-4 py-2 bg-purple-600 text-white rounded-md hover:bg-purple-700">Live Preview</button>
                <button id="save-json" class="px-4 py-2 bg-green-600 text-white rounded-md hover:bg-green-700">Save JSON</button>
                <label for="load-json-input" class="px-4 py-2 bg-yellow-500 text-white rounded-md hover:bg-yellow-600 cursor-pointer">Load JSON</label>
                <input type="file" id="load-json-input" class="hidden" accept=".json">
                
                <a href="docs.html" target="_blank" class="px-4 py-2 bg-gray-600 text-white rounded-md hover:bg-gray-700 flex items-center">
                    <span class="material-symbols-outlined text-sm mr-1">description</span> Docs
                </a>
            </div>
        </header>

        <!-- Main Content -->
        <div class="flex flex-1 overflow-hidden">
            <!-- Left Sidebar -->
            <aside class="w-64 bg-white p-4 overflow-y-auto shadow-lg z-10">
                <h2 class="text-lg font-semibold mb-4">Components</h2>
                <div class="space-y-4">
                    <div>
                        <label for="component-select" class="block text-sm font-medium text-gray-700">Select a component</label>
                        <select id="component-select" class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md">
                            <option>Button</option>
                            <option>Label</option>
                            <option>TextBox</option>
                            <option>TextArea</option>
                            <option>Checkbox</option>
                            <option>RadioGroup</option>
                            <option>Dropdown</option>
                            <option>Slider</option>
                            <option>Panel</option>
                            <option>ProgressBar</option>
                            <option>Spinner</option>
                            <option>CardView</option>
                            <option>ToggleButton</option>
                            <option>Image</option>
                        </select>
                    </div>
                    <button id="add-component" class="w-full px-4 py-2 bg-indigo-600 text-white rounded-md hover:bg-indigo-700">Add Component</button>
                </div>
                <div class="mt-6 p-4 bg-gray-50 rounded-lg">
                    <h3 class="font-semibold text-gray-800">Instructions</h3>
                    <p class="text-sm text-gray-600 mt-2">
                        1. Select a component and click "Add Component".<br>
                        2. Right-click to <b>Group</b>, <b>Lock</b>, or <b>Align</b>.<br>
                        3. Right-click Panel/CardView/ProgressBar/Image to <b>Attach</b>.<br>
                        4. CardView can become a hybrid (base + component).<br>
                        5. Components have minimized top/left borders.<br>
                    </p>
                </div>
            </aside>

            <!-- Canvas Container -->
            <main class="flex-1 p-4 bg-gray-200 flex justify-center overflow-y-auto relative">
                
                <!-- Floating Settings Menu (Outside Canvas, Inside Wrapper) -->
                <div class="absolute top-4 right-4 z-50 flex flex-col items-end pointer-events-auto">
                    <button id="settings-btn" class="bg-white p-2 rounded-full shadow-md text-gray-600 hover:text-gray-800 hover:bg-gray-50 focus:outline-none transition-colors border border-gray-200">
                        <span class="material-symbols-outlined">settings</span>
                    </button>
                    
                    <div id="settings-menu" class="hidden mt-2 w-56 bg-white rounded-md shadow-lg border border-gray-200 p-3">
                        <h4 class="text-xs font-bold text-gray-500 uppercase tracking-wider mb-3">Settings</h4>
                        
                        <!-- Alignment Toggle -->
                        <div class="flex items-center justify-between mb-4">
                            <span class="text-sm font-medium text-gray-700">Alignment Helper</span>
                            <div class="relative inline-block w-10 mr-2 align-middle select-none transition duration-200 ease-in">
                                <input type="checkbox" name="toggle" id="alignment-toggle" class="toggle-checkbox absolute block w-5 h-5 rounded-full bg-white border-4 appearance-none cursor-pointer" style="top: 2px; left: 2px; transition: all 0.3s;" checked/>
                                <label for="alignment-toggle" class="toggle-label block overflow-hidden h-6 rounded-full bg-gray-300 cursor-pointer"></label>
                            </div>
                        </div>

                        <!-- Locked Lines Toggle -->
                        <div class="flex items-center justify-between">
                            <span class="text-sm font-medium text-gray-700">Show Locked Lines</span>
                            <div class="relative inline-block w-10 mr-2 align-middle select-none transition duration-200 ease-in">
                                <input type="checkbox" name="toggle" id="locked-lines-toggle" class="toggle-checkbox absolute block w-5 h-5 rounded-full bg-white border-4 appearance-none cursor-pointer" style="top: 2px; left: 2px; transition: all 0.3s;" checked/>
                                <label for="locked-lines-toggle" class="toggle-label block overflow-hidden h-6 rounded-full bg-gray-300 cursor-pointer"></label>
                            </div>
                        </div>
                    </div>
                </div>

                <div id="canvas-wrapper" class="relative">
                    
                    <!-- Floating Group Control -->
                    <div id="grouping-control" class="floating-control-bar">
                        <span class="text-sm font-medium">Select components to group...</span>
                        <button id="finish-grouping-btn" class="bg-green-500 hover:bg-green-600 text-white text-xs px-3 py-1 rounded-full font-bold">Done</button>
                        <button id="cancel-grouping-btn" class="bg-gray-500 hover:bg-gray-600 text-white text-xs px-2 py-1 rounded-full">&times;</button>
                    </div>

                    <!-- Floating Alignment Control -->
                    <div id="alignment-control" class="floating-control-bar">
                        <span class="text-sm font-medium">Select component to align to...</span>
                        <button id="cancel-alignment-btn" class="bg-white text-blue-600 hover:bg-gray-100 text-xs px-2 py-1 rounded-full font-bold">Cancel</button>
                    </div>

                    <!-- Floating Attachment Control -->
                    <div id="attachment-control" class="floating-control-bar">
                        <span class="text-sm font-medium">Select components to attach to base...</span>
                        <button id="finish-attachment-btn" class="bg-green-500 hover:bg-green-600 text-white text-xs px-3 py-1 rounded-full font-bold">Attach</button>
                        <button id="cancel-attachment-btn" class="bg-gray-500 hover:bg-gray-600 text-white text-xs px-2 py-1 rounded-full">&times;</button>
                    </div>

                    <div id="canvas" class="canvas shadow-lg relative show-locked-outlines" style="width: 800px; height: 600px;">
                        <!-- Alignment Guide Lines -->
                        <div id="guide-x" class="guide-line" style="width: 1px; height: 100%;"></div>
                        <div id="guide-y" class="guide-line" style="height: 1px; width: 100%;"></div>
                        
                        <!-- Margin Tool Floating Popup -->
                        <div id="margin-tool-popup">
                            <div class="flex justify-between items-center mb-2">
                                <span class="text-sm font-bold text-gray-700">Smart Border</span>
                                <button id="close-margin-tool" class="text-gray-400 hover:text-red-500 text-xs">&times;</button>
                            </div>
                            <div class="mb-1 text-xs text-gray-500 flex justify-between">
                                <span>Fill (0)</span>
                                <span id="margin-value-display">0px</span>
                                <span>(100)</span>
                            </div>
                            <input type="range" id="margin-slider" min="0" max="100" value="0" class="w-full appearance-none h-1 bg-gray-200 rounded outline-none slider-thumb">
                        </div>
                    </div>
                </div>

            </main>

            <!-- Right Sidebar (Property Editor) -->
            <aside id="property-editor" class="w-80 bg-white p-4 overflow-y-auto shadow-lg z-10 hidden">
                <h2 class="text-lg font-semibold mb-4">Properties</h2>
                <div id="properties-form" class="space-y-4"></div>
                <button id="delete-component" class="w-full mt-6 px-4 py-2 bg-red-600 text-white rounded-md hover:bg-red-700">Delete Component</button>
            </aside>
        </div>
    </div>
    
    <!-- Custom Context Menu -->
    <div id="context-menu" class="hidden absolute bg-white shadow-lg rounded-md py-1 z-50 border border-gray-200">
        <!-- Main Actions -->
        <a href="#" data-action="duplicate" class="block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 flex items-center gap-2">
            <span class="material-symbols-outlined text-[18px]">content_copy</span> Duplicate
        </a>

        <div class="border-t my-1"></div>
        
        <!-- Locking Actions -->
        <a href="#" id="ctx-lock" data-action="lock" class="block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 flex items-center gap-2">
            <span class="material-symbols-outlined text-[18px]">lock</span> Lock
        </a>
        <a href="#" id="ctx-unlock" data-action="unlock" class="hidden px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 flex items-center gap-2">
            <span class="material-symbols-outlined text-[18px]">lock_open</span> Unlock
        </a>

        <!-- Grouping Actions -->
        <a href="#" id="ctx-group" data-action="start-grouping" class="block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 flex items-center gap-2">
            <span class="material-symbols-outlined text-[18px]">dataset</span> Start Grouping
        </a>
        <a href="#" id="ctx-ungroup" data-action="ungroup" class="hidden px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 flex items-center gap-2">
            <span class="material-symbols-outlined text-[18px]">grid_off</span> Break Group
        </a>
        
        <!-- NEW: Attachment Action - ONLY SHOWN FOR BASE COMPONENTS AND HYBRIDS -->
        <a href="#" id="ctx-attach" data-action="start-attachment" class="hidden px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 flex items-center gap-2">
            <span class="material-symbols-outlined text-[18px]">layers</span> Attach Components
        </a>
        <a href="#" id="ctx-detach" data-action="detach" class="hidden px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 flex items-center gap-2">
            <span class="material-symbols-outlined text-[18px]">layers_clear</span> Detach from Base
        </a>
        
        <div class="border-t my-1"></div>

        <!-- ALIGN RELATIVE MENU (Nested) -->
        <div class="submenu-container relative">
            <a href="#" class="flex justify-between items-center w-full px-4 py-2 text-sm text-gray-700 hover:bg-gray-100">
                <span class="flex items-center gap-2"><span class="material-symbols-outlined text-[18px]">align_horizontal_left</span> Align Relative...</span>
                <span class="material-symbols-outlined text-[16px]">chevron_right</span>
            </a>
            <div class="submenu hidden absolute left-full top-0 mt-[-5px] bg-white shadow-lg rounded-md py-1 w-40 border border-gray-200">
                <!-- Horizontal Submenu -->
                <div class="submenu-container relative">
                    <a href="#" class="flex justify-between items-center w-full px-4 py-2 text-sm text-gray-700 hover:bg-gray-100">
                        <span>Horizontal</span>
                        <span class="material-symbols-outlined text-[16px]">chevron_right</span>
                    </a>
                    <div class="submenu hidden absolute left-full top-0 mt-[-5px] bg-white shadow-lg rounded-md py-1 w-40 border border-gray-200">
                        <a href="#" data-action="align-h-left" class="block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100">Left Corner</a>
                        <a href="#" data-action="align-h-right" class="block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100">Right Corner</a>
                        <a href="#" data-action="align-h-center" class="block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100">Center</a>
                    </div>
                </div>
                <!-- Vertical Submenu -->
                <div class="submenu-container relative">
                    <a href="#" class="flex justify-between items-center w-full px-4 py-2 text-sm text-gray-700 hover:bg-gray-100">
                        <span>Vertical</span>
                        <span class="material-symbols-outlined text-[16px]">chevron_right</span>
                    </a>
                    <div class="submenu hidden absolute left-full top-0 mt-[-5px] bg-white shadow-lg rounded-md py-1 w-40 border border-gray-200">
                        <a href="#" data-action="align-v-top" class="block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100">Up (Top)</a>
                        <a href="#" data-action="align-v-bottom" class="block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100">Down (Bottom)</a>
                        <a href="#" data-action="align-v-center" class="block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100">Center</a>
                    </div>
                </div>
            </div>
        </div>

        <!-- Z-Index Submenu -->
        <div class="submenu-container relative">
            <a href="#" class="flex justify-between items-center w-full px-4 py-2 text-sm text-gray-700 hover:bg-gray-100">
                <span class="flex items-center gap-2"><span class="material-symbols-outlined text-[18px]">layers</span> Layer Order</span>
                <span class="material-symbols-outlined text-[16px]">chevron_right</span>
            </a>
            <div class="submenu hidden absolute left-full top-0 mt-[-5px] bg-white shadow-lg rounded-md py-1 w-48 border border-gray-200">
                <a href="#" data-action="bring-forward" class="block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100">Bring Forward</a>
                <a href="#" data-action="send-backward" class="block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100">Send Backward</a>
                <div class="border-t my-1"></div>
                <a href="#" data-action="bring-to-front" class="block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100">Bring to Front</a>
                <a href="#" data-action="send-to-back" class="block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100">Send to Back</a>
            </div>
        </div>

        <!-- Resize & Align Submenu -->
        <div class="submenu-container relative">
            <a href="#" class="flex justify-between items-center w-full px-4 py-2 text-sm text-gray-700 hover:bg-gray-100">
                <span class="flex items-center gap-2"><span class="material-symbols-outlined text-[18px]">aspect_ratio</span> Resize & Align</span>
                <span class="material-symbols-outlined text-[16px]">chevron_right</span>
            </a>
            <div class="submenu hidden absolute left-full top-0 mt-[-5px] bg-white shadow-lg rounded-md py-1 w-48 border border-gray-200">
                <a href="#" data-action="center-window" class="block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 flex items-center gap-2">
                    <span class="material-symbols-outlined text-[16px]">center_focus_strong</span> Center to Window
                </a>
                <a href="#" data-action="fit-window" class="block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 flex items-center gap-2">
                    <span class="material-symbols-outlined text-[16px]">fullscreen</span> Fit to Window
                </a>
                <div class="border-t my-1"></div>
                <a href="#" data-action="smart-border" class="block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 flex items-center gap-2">
                    <span class="material-symbols-outlined text-[16px]">border_outer</span> Smart Border...
                </a>
            </div>
        </div>
    </div>

    <!-- Live Preview Modal -->
    <div id="preview-modal" class="fixed inset-0 z-50 hidden items-center justify-center">
        <div id="preview-content" class="bg-white rounded-lg shadow-xl flex flex-col w-full h-full max-w-4xl max-h-[80%]">
            <div class="p-2 border-b flex justify-between items-center bg-gray-50 rounded-t-lg">
                <h3 class="text-lg font-semibold text-gray-700">Live Preview</h3>
                <div>
                    <button id="fullscreen-preview-btn" class="px-3 py-1 bg-gray-200 text-gray-700 rounded-md hover:bg-gray-300 text-sm">Full Screen</button>
                    <button id="close-preview-btn" class="ml-2 px-3 py-1 bg-red-500 text-white rounded-md hover:bg-red-600 text-sm">&times; Close</button>
                </div>
            </div>
            <div class="p-4 flex-1 bg-gray-100 overflow-auto">
                <div id="preview-canvas" class="bg-white relative shadow-inner"></div>
            </div>
        </div>
    </div>

    <!-- Layer Tree Modal -->
    <div id="layer-tree-modal">
        <div class="layer-tree-container">
            <div class="layer-tree-header">
                <h3 class="text-lg font-semibold">Layer Tree View</h3>
                <button id="close-layer-tree" class="text-white hover:text-gray-200">
                    <span class="material-symbols-outlined">close</span>
                </button>
            </div>
            <div class="layer-tree-content">
                <div id="layer-tree-list"></div>
            </div>
            <div class="p-4 border-t bg-gray-50">
                <button id="apply-layer-changes" class="w-full px-4 py-2 bg-indigo-600 text-white rounded-md hover:bg-indigo-700">Apply Changes</button>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('canvas');
            const addComponentBtn = document.getElementById('add-component');
            const componentSelect = document.getElementById('component-select');
            const propertyEditor = document.getElementById('property-editor');
            const propertiesForm = document.getElementById('properties-form');
            const saveJsonBtn = document.getElementById('save-json');
            const loadJsonInput = document.getElementById('load-json-input');
            const resizeCanvasBtn = document.getElementById('resize-canvas');
            const canvasWidthInput = document.getElementById('canvas-width');
            const canvasHeightInput = document.getElementById('canvas-height');
            const deleteComponentBtn = document.getElementById('delete-component');
            const livePreviewBtn = document.getElementById('live-preview-btn');
            const previewModal = document.getElementById('preview-modal');
            const previewCanvas = document.getElementById('preview-canvas');
            const previewContent = document.getElementById('preview-content');
            const closePreviewBtn = document.getElementById('close-preview-btn');
            const fullscreenPreviewBtn = document.getElementById('fullscreen-preview-btn');
            const contextMenu = document.getElementById('context-menu');
            const windowTitleInput = document.getElementById('window-title');
            const layerTreeBtn = document.getElementById('layer-tree-btn');
            const layerTreeModal = document.getElementById('layer-tree-modal');
            const layerTreeList = document.getElementById('layer-tree-list');
            const closeLayerTree = document.getElementById('close-layer-tree');
            const applyLayerChanges = document.getElementById('apply-layer-changes');
            const compactModeBtn = document.getElementById('compact-mode-btn');
            
            // Settings & Helper Variables
            const settingsBtn = document.getElementById('settings-btn');
            const settingsMenu = document.getElementById('settings-menu');
            const alignmentToggle = document.getElementById('alignment-toggle');
            const lockedLinesToggle = document.getElementById('locked-lines-toggle');
            const guideX = document.getElementById('guide-x');
            const guideY = document.getElementById('guide-y');

            // Margin Tool Variables
            const marginToolPopup = document.getElementById('margin-tool-popup');
            const marginSlider = document.getElementById('margin-slider');
            const marginValueDisplay = document.getElementById('margin-value-display');
            const closeMarginTool = document.getElementById('close-margin-tool');

            // Grouping & Locking Variables
            const groupingControl = document.getElementById('grouping-control');
            const finishGroupingBtn = document.getElementById('finish-grouping-btn');
            const cancelGroupingBtn = document.getElementById('cancel-grouping-btn');
            
            // Alignment Variables
            const alignmentControl = document.getElementById('alignment-control');
            const cancelAlignmentBtn = document.getElementById('cancel-alignment-btn');
            
            // Attachment Variables
            const attachmentControl = document.getElementById('attachment-control');
            const finishAttachmentBtn = document.getElementById('finish-attachment-btn');
            const cancelAttachmentBtn = document.getElementById('cancel-attachment-btn');
            
            let alignmentHelperEnabled = true;
            const SNAP_THRESHOLD = 5;
            let isCompactMode = false;

            let components = [];
            let selectedComponent = null;
            let componentIdCounter = 0;
            let contextComponentId = null;

            // --- STATE (LOCAL ONLY) ---
            const groupMap = new Map(); // Key: componentId, Value: groupId
            const lockedComponents = new Set(); // Value: componentId
            const attachmentMap = new Map(); // Key: childId, Value: parentId (for z-index attachment)
            const hybridBases = new Set(); // Value: componentId (components that are both base and child)
            let tempGroupSelection = new Set(); // Used during selection mode
            let tempAttachmentSelection = new Set(); // Used during attachment mode
            let isGroupingMode = false;
            let isAttachmentMode = false;
            let attachmentBaseId = null;
            let groupIdCounter = 0;
            
            // --- ALIGNMENT MODE STATE ---
            let isAlignmentMode = false;
            let alignSourceId = null;
            let pendingAlignmentType = null;

            // Define which components can be bases
            const BASE_COMPONENTS = ['Panel', 'CardView', 'ProgressBar', 'Image'];
            
            // Define which components can be children (all except bases)
            const CHILD_COMPONENTS = ['Button', 'Label', 'TextBox', 'TextArea', 'Checkbox', 
                                      'RadioGroup', 'Dropdown', 'Slider', 'Spinner', 'ToggleButton'];
            
            // Define which components can become hybrids (CardView only)
            const HYBRID_COMPONENTS = ['CardView'];

            // Fix: Close context menu when clicking anywhere else
            document.addEventListener('click', (e) => {
                if (!contextMenu.contains(e.target) && !e.target.closest('[data-action]')) {
                    contextMenu.classList.add('hidden');
                }
                if (!settingsMenu.contains(e.target) && e.target !== settingsBtn) {
                    settingsMenu.classList.add('hidden');
                }
                if (!marginToolPopup.contains(e.target) && e.target.dataset.action !== 'smart-border' && e.target.tagName !== 'INPUT') {
                   if(e.target === canvas) marginToolPopup.style.display = 'none';
                }
            });

            // Also close on touch events for mobile
            document.addEventListener('touchstart', (e) => {
                if (!contextMenu.contains(e.target) && !e.target.closest('[data-action]')) {
                    contextMenu.classList.add('hidden');
                }
            });

            // Toggle Compact Mode
            compactModeBtn.addEventListener('click', () => {
                isCompactMode = !isCompactMode;
                if (isCompactMode) {
                    canvas.classList.add('compact-mode');
                    compactModeBtn.classList.add('bg-indigo-500', 'text-white');
                    compactModeBtn.classList.remove('bg-gray-200', 'text-gray-700');
                } else {
                    canvas.classList.remove('compact-mode');
                    compactModeBtn.classList.remove('bg-indigo-500', 'text-white');
                    compactModeBtn.classList.add('bg-gray-200', 'text-gray-700');
                }
                renderAllComponents();
            });

            // Toggle Settings Menu
            settingsBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                settingsMenu.classList.toggle('hidden');
            });

            // Toggle Alignment Helper
            alignmentToggle.addEventListener('change', (e) => {
                alignmentHelperEnabled = e.target.checked;
            });

            // Toggle Locked Lines Visuals
            lockedLinesToggle.addEventListener('change', (e) => {
                if(e.target.checked) {
                    canvas.classList.add('show-locked-outlines');
                } else {
                    canvas.classList.remove('show-locked-outlines');
                }
            });

            const getComponentDefaults = (type) => {
                const base = { textColor: '#000000', fontSize: 14, bold: false };
                const textBase = { ...base, text: type };
                const placeholderImg = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgZmlsbD0iI2U1ZTVlNSIvPjx0ZXh0IHg9IjUwIiB5PSI1MCIgZm9udC1mYW1pbHk9IkFyaWFsIiBmb250LXNpemU9IjEyIiBmaWxsPSIjOTk5IiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBkb21pbmFudC1iYXNlbGluZT0iY2VudHJhbCI+RW1wdHkgSW1hZ2U8L3RleHQ+PC9zdmc+';
                
                switch (type) {
                    case 'Button': return { ...textBase, backgroundColor: '#f3f4f6', cornerRadius: 4 };
                    case 'Label': return { ...textBase, iconName: '' };
                    case 'TextBox': return { text: '', hintText: 'Enter text...', hintColor: '#9ca3af', backgroundColor: '#ffffff', ...base };
                    case 'TextArea': return { text: '', hintText: 'Enter text...', hintColor: '#9ca3af', backgroundColor: '#ffffff', ...base };
                    case 'Checkbox': return { text: 'Checkbox', checked: false, checkedColor: '#3b82f6', ...base };
                    case 'RadioGroup': return { label: 'Select an Option', options: 'Option 1\nOption 2', checkedValue: 'Option 1', checkedColor: '#3b82f6', ...base };
                    case 'Dropdown': return { text: 'Dropdown', options: 'Option 1\nOption 2', backgroundColor: '#ffffff', selectionColor: '#dbeafe', ...base };
                    case 'Slider': return { min: 0, max: 100, value: 50, progressColor: '#3b82f6', buttonColor: '#3b82f6' };
                    case 'Panel': return { backgroundColor: '#f3f4f6', cornerRadius: 0 };
                    case 'ProgressBar': return { value: 50, progressColor: '#3b82f6', textColor: '#000000', textPosition: 'right' };
                    case 'Spinner': return { min: 0, max: 100, value: 25, backgroundColor: '#ffffff', ...base };
                    case 'CardView': return { ...textBase, backgroundColor: '#ffffff', cornerRadius: 8, elevation: 2 };
                    case 'ToggleButton': return { checked: false, onColor: '#34d399', offColor: '#d1d5db' };
                    case 'Image': return { src: placeholderImg, cornerRadius: 0, opacity: 1, fit: 'cover', backgroundColor: '#ffffff' };
                    default: return textBase;
                }
            };

            resizeCanvasBtn.addEventListener('click', () => {
                canvas.style.width = `${canvasWidthInput.value}px`;
                canvas.style.height = `${canvasHeightInput.value}px`;
            });

            addComponentBtn.addEventListener('click', () => {
                const componentType = componentSelect.value;
                let id = `${componentType.toLowerCase()}_${componentIdCounter++}`;
                while (components.some(c => c.id === id)) {
                    id = `${componentType.toLowerCase()}_${componentIdCounter++}`;
                }
                
                const componentData = {
                    id: id, type: componentType, x: 50, y: 50,
                    width: 150, height: 40,
                    zIndex: components.length,
                    properties: getComponentDefaults(componentType)
                };
                
                if(componentType === 'Image' || componentType === 'RadioGroup') componentData.height = 100;
                if(componentType === 'Slider') componentData.width = 200;
                if(componentType === 'TextArea') componentData.height = 80;
                if(componentType === 'Panel' || componentType === 'CardView') { componentData.width = 200; componentData.height = 150; }
                if(componentType === 'ProgressBar' || componentType === 'Slider') componentData.height = 25;
                if(componentType === 'ToggleButton') { componentData.width = 60; componentData.height = 32; }
                if(componentType === 'Label') { componentData.width = 40; componentData.height = 40; }

                components.push(componentData);
                renderAllComponents();
                selectComponent(id);
            });
            
            function reorderZIndexes() {
                components.sort((a, b) => a.zIndex - b.zIndex);
                components.forEach((c, index) => c.zIndex = index);
                renderAllComponents();
            }

            function renderAllComponents() {
                // Sort by zIndex but respect attachment hierarchy
                const sortedComponents = [...components];
                sortedComponents.sort((a, b) => {
                    // If attached to same parent, sort by their own zIndex
                    const aParent = attachmentMap.get(a.id);
                    const bParent = attachmentMap.get(b.id);
                    
                    if (aParent === bParent) {
                        return a.zIndex - b.zIndex;
                    }
                    
                    // If one is parent of another, parent should be lower
                    if (aParent === b.id) return 1;
                    if (bParent === a.id) return -1;
                    
                    // Otherwise sort normally
                    return a.zIndex - b.zIndex;
                });
                
                const preservedElements = [
                    document.getElementById('guide-x'),
                    document.getElementById('guide-y'),
                    document.getElementById('margin-tool-popup'),
                    document.getElementById('grouping-control'),
                    document.getElementById('alignment-control'),
                    document.getElementById('attachment-control')
                ];
                
                canvas.innerHTML = '';
                preservedElements.forEach(el => {
                    if(el) canvas.appendChild(el);
                });

                sortedComponents.forEach(comp => renderComponent(comp, true));
            }

            function renderComponent(comp, isBatchRender = false) {
                let el = document.getElementById(comp.id);
                if (!el) {
                    el = document.createElement('div');
                    el.id = comp.id;
                    el.className = 'component';
                    
                    // Add type-specific classes for border styling
                    if (comp.type === 'Panel') el.classList.add('panel-type');
                    if (comp.type === 'CardView') el.classList.add('cardview-type');
                    if (comp.type === 'Image') el.classList.add('image-type');
                    if (comp.type === 'ProgressBar') el.classList.add('progressbar-type');
                    
                    // Check if component is a hybrid
                    if (hybridBases.has(comp.id)) {
                        el.classList.add('hybrid-base');
                    }
                    
                    canvas.appendChild(el);
                    
                    const resizer = document.createElement('div');
                    resizer.className = 'resizer';
                    el.appendChild(resizer);
                    
                    makeDraggable(el);
                    makeResizable(el, resizer);

                    el.addEventListener('click', (e) => {
                        e.stopPropagation();
                        // If in grouping mode, handle selection differently
                        if (isGroupingMode) {
                            if (tempGroupSelection.has(comp.id)) {
                                tempGroupSelection.delete(comp.id);
                                el.classList.remove('group-selecting');
                            } else {
                                tempGroupSelection.add(comp.id);
                                el.classList.add('group-selecting');
                            }
                            return;
                        }
                        
                        // If in attachment mode, handle selection
                        if (isAttachmentMode) {
                            if (!attachmentBaseId) {
                                // First click selects the base
                                attachmentBaseId = comp.id;
                                el.classList.add('attachment-base');
                                attachmentControl.querySelector('span').textContent = `Base selected. Select children to attach...`;
                            } else if (attachmentBaseId === comp.id) {
                                // Clicking base again deselects it
                                attachmentBaseId = null;
                                el.classList.remove('attachment-base');
                                attachmentControl.querySelector('span').textContent = `Select components to attach to base...`;
                                tempAttachmentSelection.clear();
                            } else {
                                // Select children based on attachment rules
                                if (canAttachAsChild(comp.id, attachmentBaseId)) {
                                    if (tempAttachmentSelection.has(comp.id)) {
                                        tempAttachmentSelection.delete(comp.id);
                                        el.classList.remove('attachment-child');
                                    } else {
                                        tempAttachmentSelection.add(comp.id);
                                        el.classList.add('attachment-child');
                                    }
                                } else {
                                    alert(getAttachmentErrorMessage(comp.id, attachmentBaseId));
                                }
                            }
                            return;
                        }
                        
                        // If in alignment mode, perform alignment
                        if (isAlignmentMode) {
                            performAlignment(comp.id);
                            return;
                        }
                        
                        selectComponent(comp.id);
                    });

                    el.addEventListener('contextmenu', e => {
                        e.preventDefault();
                        e.stopPropagation();
                        // Don't open context menu if in special modes
                        if (isGroupingMode || isAlignmentMode || isAttachmentMode) return;
                        
                        contextComponentId = comp.id;
                        contextMenu.style.top = `${e.clientY}px`;
                        contextMenu.style.left = `${e.clientX}px`;
                        
                        // Update Context Menu Items based on state
                        const isLocked = lockedComponents.has(comp.id);
                        const isGrouped = groupMap.has(comp.id);
                        const hasParent = attachmentMap.has(comp.id);
                        const isHybrid = hybridBases.has(comp.id);
                        const canBeBase = BASE_COMPONENTS.includes(comp.type);
                        const canShowAttach = (canBeBase || isHybrid) && !hasParent;
                        
                        document.getElementById('ctx-lock').classList.toggle('hidden', isLocked);
                        document.getElementById('ctx-unlock').classList.toggle('hidden', !isLocked);
                        
                        document.getElementById('ctx-group').classList.toggle('hidden', isGrouped);
                        document.getElementById('ctx-ungroup').classList.toggle('hidden', !isGrouped);
                        
                        // Show "Attach Components" for base-compatible components and hybrids
                        document.getElementById('ctx-attach').classList.toggle('hidden', !canShowAttach);
                        
                        // Show "Detach from Base" for child components (including hybrids)
                        document.getElementById('ctx-detach').classList.toggle('hidden', !hasParent);

                        contextMenu.classList.remove('hidden');
                        selectComponent(comp.id);
                        
                        marginToolPopup.style.display = 'none';
                    });
                }

                // Apply states
                if (lockedComponents.has(comp.id)) el.classList.add('locked');
                else el.classList.remove('locked');

                if (isGroupingMode && tempGroupSelection.has(comp.id)) el.classList.add('group-selecting');
                else el.classList.remove('group-selecting');
                
                if (isAlignmentMode && comp.id !== alignSourceId) el.classList.add('align-target-selectable');
                else el.classList.remove('align-target-selectable');
                
                if (isAttachmentMode) {
                    if (attachmentBaseId === comp.id) el.classList.add('attachment-base');
                    else if (tempAttachmentSelection.has(comp.id)) el.classList.add('attachment-child');
                    else {
                        el.classList.remove('attachment-base', 'attachment-child');
                    }
                } else {
                    el.classList.remove('attachment-base', 'attachment-child');
                }

                // Update hybrid status
                if (hybridBases.has(comp.id)) {
                    el.classList.add('hybrid-base');
                } else {
                    el.classList.remove('hybrid-base');
                }

                el.style.left = `${comp.x}px`;
                el.style.top = `${comp.y}px`;
                el.style.width = `${comp.width}px`;
                el.style.height = `${comp.height}px`;
                el.style.zIndex = comp.zIndex;

                el.innerHTML = getComponentHTML(comp) + (el.querySelector('.resizer')?.outerHTML || '<div class="resizer"></div>');
                makeResizable(el, el.querySelector('.resizer'));

                if (selectedComponent && selectedComponent.id === comp.id) {
                    el.classList.add('selected');
                }
            }

            function canAttachAsChild(childId, parentId) {
                const childComp = components.find(c => c.id === childId);
                const parentComp = components.find(c => c.id === parentId);
                
                if (!childComp || !parentComp) return false;
                
                // Rule 1: Panel can attach CardView as child (CardView becomes hybrid)
                if (parentComp.type === 'Panel' && childComp.type === 'CardView') {
                    return true;
                }
                
                // Rule 2: CardView (hybrid or base) can attach regular children
                if ((parentComp.type === 'CardView' || hybridBases.has(parentId)) && 
                    (CHILD_COMPONENTS.includes(childComp.type) || childComp.type === 'CardView')) {
                    // CardView can attach another CardView as child (nested CardViews)
                    return true;
                }
                
                // Rule 3: Other bases (ProgressBar, Image) can only attach regular children
                if (BASE_COMPONENTS.includes(parentComp.type) && CHILD_COMPONENTS.includes(childComp.type)) {
                    return true;
                }
                
                // Rule 4: Hybrid CardViews can attach regular children
                if (hybridBases.has(parentId) && CHILD_COMPONENTS.includes(childComp.type)) {
                    return true;
                }
                
                return false;
            }

            function getAttachmentErrorMessage(childId, parentId) {
                const childComp = components.find(c => c.id === childId);
                const parentComp = components.find(c => c.id === parentId);
                
                if (!childComp || !parentComp) return "Invalid components.";
                
                // Panel cannot be attached as child to anything
                if (childComp.type === 'Panel') {
                    return "Panel cannot be attached as a child component. Panel can only be a base.";
                }
                
                // ProgressBar and Image can only be bases, not children
                if (childComp.type === 'ProgressBar' || childComp.type === 'Image') {
                    return `${childComp.type} can only be a base, not a child component.`;
                }
                
                // CardView attached to Panel becomes hybrid
                if (parentComp.type === 'Panel' && childComp.type === 'CardView') {
                    return "CardView can be attached to Panel and will become a hybrid (base + component).";
                }
                
                return `Cannot attach ${childComp.type} as child of ${parentComp.type}.`;
            }

            function getComponentHTML(comp) {
                const p = comp.properties;
                const baseStyles = `color:${p.textColor}; font-size:${p.fontSize}px; font-weight:${p.bold ? 'bold' : 'normal'};`;
                let wrapperStyles = `background-color:${p.backgroundColor || 'white'}; border-radius:${p.cornerRadius || 0}px;`;
                
                switch(comp.type) {
                    case 'Image':
                        return `<div class="component-render-wrapper" style="padding:0; border:none; background:transparent;">
                                    <img src="${p.src}" style="width:100%; height:100%; object-fit:${p.fit}; border-radius:${p.cornerRadius}px; opacity:${p.opacity};" />
                                </div>`;
                    case 'Button':
                    case 'CardView':
                         if(comp.type === 'CardView') wrapperStyles += ` box-shadow: 0 ${p.elevation*2}px ${p.elevation*3}px rgba(0,0,0,0.1);`;
                         return `<div class="component-render-wrapper" style="${wrapperStyles}"><span style="${baseStyles}">${p.text}</span></div>`;
                    case 'Panel':
                         return `<div class="component-render-wrapper" style="${wrapperStyles}"></div>`;
                    case 'Label':
                        if (p.iconName && p.iconName.trim() !== '') {
                            const iconStyles = `font-family: 'Material Symbols Outlined'; font-size: ${p.fontSize}px; color:${p.textColor};`;
                            return `<div class="component-render-wrapper" style="border:none; background:transparent;"><span class="material-symbols-outlined" style="${iconStyles}">${p.iconName}</span></div>`;
                        }
                        return `<div class="component-render-wrapper" style="border:none; background:transparent;"><span style="${baseStyles}">${p.text}</span></div>`;
                    case 'TextBox':
                    case 'TextArea':
                        const hint = `<span style='color:${p.hintColor};'>${p.hintText}</span>`;
                        const align = comp.type === 'TextArea' ? 'align-self: flex-start;' : '';
                        return `<div class="component-render-wrapper" style="${wrapperStyles}">
                                    <span style="${baseStyles} width: 100%; text-align: left; ${align}">${p.text || hint}</span>
                                </div>`;
                    case 'Checkbox':
                        return `<div class="component-render-wrapper" style="border:none; background:transparent; justify-content:flex-start;">
                                    <div style="display:flex; align-items:center; gap:8px;">
                                        <div style="width:16px; height:16px; border:1px solid #9ca3af; display:flex; align-items:center; justify-content:center; background:${p.checked ? p.checkedColor : 'white'}; border-radius: 2px">
                                            ${p.checked ? '<svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="3"><path d="M20 6L9 17l-5-5"></path></svg>' : ''}
                                        </div>
                                        <span style="${baseStyles}">${p.text}</span>
                                    </div>
                                </div>`;
                    case 'RadioGroup':
                        let radioHTML = `<div style="${baseStyles} margin-bottom: 8px;">${p.label}</div>`;
                        const options = p.options.split('\n');
                        options.forEach(opt => {
                            const isChecked = opt === p.checkedValue;
                            radioHTML += `<div style="display:flex; align-items:center; gap:8px; margin-bottom: 4px;">
                                            <div style="width:16px; height:16px; border:1px solid #9ca3af; display:flex; align-items:center; justify-content:center; background:${isChecked ? p.checkedColor : 'white'}; border-radius:50%">
                                                ${isChecked ? `<div style="width:8px; height:8px; background:white; border-radius:50%;"></div>` : ''}
                                            </div>
                                            <span style="${baseStyles}">${opt}</span>
                                        </div>`;
                        });
                        return `<div class="component-render-wrapper" style="border:none; background:transparent; flex-direction: column; align-items: flex-start;">${radioHTML}</div>`;
                    case 'ProgressBar':
                        return `<div style="width:100%; height:100%; border-radius: 999px; position:relative; display:flex; align-items:center; overflow:hidden;">
                                    <div style="width:${p.value}%; height:100%; background-color:${p.progressColor}; border-radius: 999px;"></div>
                                </div>`;
                    case 'Slider':
                        const sliderPercent = (p.value - p.min) / (p.max - p.min) * 100;
                        return `<div class="component-render-wrapper" style="border:none; background:transparent;">
                                    <div style="width:100%; height:6px; background:#e5e7eb; border-radius:3px; position:relative;">
                                        <div style="position:absolute; left:0; top:0; height:100%; width:${sliderPercent}%; background:${p.progressColor}; border-radius:3px;"></div>
                                        <div style="position:absolute; left:${sliderPercent}%; transform:translateX(-50%); top:-6px; width:18px; height:18px; background:${p.buttonColor}; border-radius:50%; border: 2px solid white; box-shadow: 0 1px 3px rgba(0,0,0,0.2);"></div>
                                    </div>
                                </div>`;
                    case 'ToggleButton':
                        return `<div class="component-render-wrapper" style="border:none; background:transparent;">
                                    <div style="width:100%; height:100%; background-color:${p.checked ? p.onColor : p.offColor}; border-radius:999px; position:relative; transition: background-color 0.2s ease;">
                                        <div style="position:absolute; top:4px; left:4px; width:24px; height:24px; background:white; border-radius:50%; box-shadow:0 1px 3px rgba(0,0,0,0.2); transition: transform 0.2s ease; transform: ${p.checked ? 'translateX(28px)' : 'translateX(0)'};"></div>
                                    </div>
                                </div>`;
                    case 'Spinner':
                        return `<div class="component-render-wrapper" style="background-color:${p.backgroundColor}; justify-content:space-between; padding:0;">
                                    <button class="h-full px-2" style="font-size:${p.fontSize}px; color:${p.textColor};">-</button>
                                    <span style="${baseStyles}">${p.value}</span>
                                    <button class="h-full px-2" style="font-size:${p.fontSize}px; color:${p.textColor};">+</button>
                                </div>`;
                    default:
                        return `<div class="component-render-wrapper" style="${wrapperStyles}"><span style="${baseStyles}">${p.text}</span></div>`;
                }
            }

            deleteComponentBtn.addEventListener('click', () => {
                if (!selectedComponent) return;
                
                // Get group ID if component is grouped
                const groupId = groupMap.get(selectedComponent.id);
                
                if (groupId !== undefined) {
                    // Find all components in the same group
                    const componentsToDelete = [];
                    groupMap.forEach((gId, cId) => {
                        if (gId === groupId) {
                            componentsToDelete.push(cId);
                        }
                    });
                    
                    // Delete all components in the group
                    componentsToDelete.forEach(id => {
                        document.getElementById(id)?.remove();
                        components = components.filter(c => c.id !== id);
                        lockedComponents.delete(id);
                        groupMap.delete(id);
                        attachmentMap.delete(id);
                        hybridBases.delete(id);
                    });
                } else {
                    // Delete single component
                    document.getElementById(selectedComponent.id)?.remove();
                    components = components.filter(c => c.id !== selectedComponent.id);
                    lockedComponents.delete(selectedComponent.id);
                    groupMap.delete(selectedComponent.id);
                    attachmentMap.delete(selectedComponent.id);
                    hybridBases.delete(selectedComponent.id);
                }
                
                selectedComponent = null;
                propertyEditor.classList.add('hidden');
                renderAllComponents();
            });

            function selectComponent(id) {
                // If in special modes, don't change main selection or open property editor
                if (isGroupingMode || isAlignmentMode || isAttachmentMode) return;

                selectedComponent = components.find(c => c.id === id) || null;
                document.querySelectorAll('.component').forEach(el => el.classList.remove('selected'));
                if (selectedComponent) {
                    document.getElementById(id)?.classList.add('selected');
                    propertyEditor.classList.remove('hidden');
                    populatePropertyEditor(selectedComponent);
                } else {
                    propertyEditor.classList.add('hidden');
                }
            }

            canvas.addEventListener('click', () => {
                if (!isGroupingMode && !isAlignmentMode && !isAttachmentMode) selectComponent(null);
            });

            function populatePropertyEditor(component) {
                propertiesForm.innerHTML = '';
                const addField = (parent, type, label, value, key, options = {}) => {
                    const div = document.createElement('div');
                    const labelEl = document.createElement('label');
                    labelEl.className = 'block text-sm font-medium text-gray-700';
                    labelEl.textContent = label;
                    
                    let input;
                    if (type === 'file-button') {
                        labelEl.htmlFor = `file-input-${component.id}`;
                        labelEl.className += ' w-full text-center px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 cursor-pointer';
                        input = document.createElement('input');
                        input.type = 'file';
                        input.id = `file-input-${component.id}`;
                        input.className = 'hidden';
                        input.accept = 'image/*';
                        input.addEventListener('change', (e) => {
                            const file = e.target.files[0];
                            if (!file) return;
                            const reader = new FileReader();
                            reader.onload = (readEvent) => {
                                updateComponentProperty(component.id, 'src', readEvent.target.result);
                            };
                            reader.readAsDataURL(file);
                        });
                        div.appendChild(labelEl);
                        div.appendChild(input);
                    } else {
                        div.appendChild(labelEl);
                        if (type === 'textarea') {
                            input = document.createElement('textarea');
                            input.rows = 3;
                        } else if (type === 'select') {
                            input = document.createElement('select');
                            options.choices.forEach(c => {
                                const opt = document.createElement('option');
                                opt.value = c;
                                opt.textContent = c.charAt(0).toUpperCase() + c.slice(1);
                                input.appendChild(opt);
                            });
                        } else {
                            input = document.createElement('input');
                            input.type = type;
                            if (options.step) input.step = options.step;
                            if (options.min) input.min = options.min;
                            if (options.max) input.max = options.max;
                        }

                        input.value = value ?? '';
                        input.dataset.key = key;
                        input.className = 'mt-1 block w-full p-2 border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500';
                        if (type === 'color') input.className += ' h-10';
                        if (type === 'checkbox') {
                            input.checked = !!value;
                            input.className = 'h-4 w-4 text-indigo-600 border-gray-300 rounded focus:ring-indigo-500';
                            div.className = 'flex items-center gap-x-2';
                            div.insertBefore(input, labelEl);
                        }

                        input.addEventListener(type === 'checkbox' ? 'change' : 'input', (e) => {
                            const originalId = component.id;
                            const val = type === 'checkbox' ? e.target.checked : e.target.value;
                            updateComponentProperty(originalId, key, val, e.target);
                        });
                        div.appendChild(input);
                    }
                    parent.appendChild(div);
                };

                addField(propertiesForm, 'text', 'ID', component.id, 'id');

                const p = component.properties;
                if (component.type === 'Image') {
                    addField(propertiesForm, 'file-button', 'Upload Image', null, 'src');
                    addField(propertiesForm, 'number', 'Corner Radius (px)', p.cornerRadius, 'cornerRadius', {min: 0});
                    addField(propertiesForm, 'range', `Opacity (${p.opacity})`, p.opacity, 'opacity', {min: 0, max: 1, step: 0.1});
                    addField(propertiesForm, 'select', 'Image Fit', p.fit, 'fit', { choices: ['fill', 'contain', 'cover', 'none'] });
                } else {
                    for (const key in p) {
                        if (key === 'fontFamily' || key === 'trackColor' || key === 'borderColor' || key === 'borderWidth') continue;

                        const label = key.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase());
                        let type = 'text';
                        if (key.includes('Color')) type = 'color';
                        else if (typeof p[key] === 'number') type = 'number';
                        else if (typeof p[key] === 'boolean') type = 'checkbox';
                        else if (key === 'options') type = 'textarea';

                        addField(propertiesForm, type, label, p[key], key);
                    }
                }
            }

            function updateComponentProperty(id, key, value, targetElement) {
                const component = components.find(c => c.id === id);
                if (!component) return;
                
                if (key === 'id') {
                    const isDuplicate = components.some(c => c.id === value && c.id !== id);
                    if (isDuplicate || value.trim() === '') {
                        if(targetElement) targetElement.classList.add('id-error');
                        return;
                    }
                    if(targetElement) targetElement.classList.remove('id-error');
                    
                    document.getElementById(id).id = value;
                    component.id = value;
                    
                    // Update state maps if ID changes
                    if (lockedComponents.has(id)) {
                        lockedComponents.delete(id);
                        lockedComponents.add(value);
                    }
                    if (groupMap.has(id)) {
                        const grp = groupMap.get(id);
                        groupMap.delete(id);
                        groupMap.set(value, grp);
                    }
                    if (attachmentMap.has(id)) {
                        const parent = attachmentMap.get(id);
                        attachmentMap.delete(id);
                        attachmentMap.set(value, parent);
                    }
                    if (hybridBases.has(id)) {
                        hybridBases.delete(id);
                        hybridBases.add(value);
                    }
                    // Update children references
                    attachmentMap.forEach((parent, child) => {
                        if (parent === id) {
                            attachmentMap.set(child, value);
                        }
                    });

                    if(selectedComponent && selectedComponent.id === id) selectedComponent.id = value;
                    return;
                }

                if (typeof component.properties[key] === 'number') {
                    value = parseFloat(value) || 0;
                }
                component.properties[key] = value;
                renderComponent(component);
                
                if ((component.type === 'Label' && key === 'iconName') && selectedComponent && selectedComponent.id === id) {
                    populatePropertyEditor(component);
                }
                if (targetElement && targetElement.type === 'range') {
                    const label = targetElement.closest('div').querySelector('label');
                    if (label) label.textContent = `${label.textContent.split('(')[0].trim()} (${value})`;
                }
            }

            // --- ALIGNMENT HELPER LOGIC (Snapping) ---
            function getSnapCoordinates(activeId, x, y, w, h) {
                let snapX = null;
                let snapY = null;
                
                const l = x; const r = x + w; const cX = x + (w / 2);
                const t = y; const b = y + h; const cY = y + (h / 2);
                const activeGuides = { x: null, y: null };
                const canvasW = canvas.offsetWidth; const canvasH = canvas.offsetHeight;
                
                if (Math.abs(cX - (canvasW / 2)) < SNAP_THRESHOLD) { snapX = (canvasW / 2) - (w / 2); activeGuides.x = canvasW / 2; }
                if (Math.abs(cY - (canvasH / 2)) < SNAP_THRESHOLD) { snapY = (canvasH / 2) - (h / 2); activeGuides.y = canvasH / 2; }

                components.forEach(comp => {
                    if (comp.id === activeId) return;
                    const oL = comp.x; const oR = comp.x + comp.width; const oCX = comp.x + (comp.width / 2);
                    const oT = comp.y; const oB = comp.y + comp.height; const oCY = comp.y + (comp.height / 2);

                    if (Math.abs(l - oL) < SNAP_THRESHOLD) { snapX = oL; activeGuides.x = oL; }
                    else if (Math.abs(l - oR) < SNAP_THRESHOLD) { snapX = oR; activeGuides.x = oR; }
                    else if (Math.abs(r - oL) < SNAP_THRESHOLD) { snapX = oL - w; activeGuides.x = oL; }
                    else if (Math.abs(r - oR) < SNAP_THRESHOLD) { snapX = oR - w; activeGuides.x = oR; }
                    else if (Math.abs(cX - oCX) < SNAP_THRESHOLD) { snapX = oCX - (w / 2); activeGuides.x = oCX; }

                    if (Math.abs(t - oT) < SNAP_THRESHOLD) { snapY = oT; activeGuides.y = oT; }
                    else if (Math.abs(t - oB) < SNAP_THRESHOLD) { snapY = oB; activeGuides.y = oB; }
                    else if (Math.abs(b - oT) < SNAP_THRESHOLD) { snapY = oT - h; activeGuides.y = oT; }
                    else if (Math.abs(b - oB) < SNAP_THRESHOLD) { snapY = oB - h; activeGuides.y = oB; }
                    else if (Math.abs(cY - oCY) < SNAP_THRESHOLD) { snapY = oCY - (h / 2); activeGuides.y = oCY; }
                });

                return { x: snapX !== null ? snapX : x, y: snapY !== null ? snapY : y, guides: activeGuides };
            }

            function updateGuides(guides) {
                if (guides.x !== null) { guideX.style.display = 'block'; guideX.style.left = `${guides.x}px`; } else { guideX.style.display = 'none'; }
                if (guides.y !== null) { guideY.style.display = 'block'; guideY.style.top = `${guides.y}px`; } else { guideY.style.display = 'none'; }
            }
            function hideGuides() { guideX.style.display = 'none'; guideY.style.display = 'none'; }

            // --- MODIFIED MAKE DRAGGABLE FOR GROUPS & LOCKING ---
            function makeDraggable(element) {
                let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
                element.onmousedown = e => {
                    // Prevent drag if resizer or locked
                    if (e.target.classList.contains('resizer')) return;
                    if (lockedComponents.has(element.id)) return; 
                    if (isGroupingMode || isAlignmentMode || isAttachmentMode) return; 

                    e.preventDefault();
                    pos3 = e.clientX;
                    pos4 = e.clientY;
                    
                    document.onmouseup = () => {
                        document.onmouseup = null;
                        document.onmousemove = null;
                        hideGuides();
                        const component = components.find(c => c.id === element.id);
                        if (component) {
                            component.x = element.offsetLeft;
                            component.y = element.offsetTop;
                        }
                        
                        // Sync group positions for all members
                        const currentGroupId = groupMap.get(element.id);
                        if (currentGroupId !== undefined) {
                            components.forEach(comp => {
                                if (groupMap.get(comp.id) === currentGroupId && comp.id !== element.id) {
                                    const peerEl = document.getElementById(comp.id);
                                    if(peerEl) {
                                        comp.x = peerEl.offsetLeft;
                                        comp.y = peerEl.offsetTop;
                                    }
                                }
                            });
                        }
                    };
                    
                    document.onmousemove = me => {
                        me.preventDefault();
                        pos1 = pos3 - me.clientX;
                        pos2 = pos4 - me.clientY;
                        pos3 = me.clientX;
                        pos4 = me.clientY;
                        
                        // Drag Logic
                        let newTop = element.offsetTop - pos2;
                        let newLeft = element.offsetLeft - pos1;

                        // Canvas Boundaries (Basic check for the leader)
                        if (newLeft < 0) newLeft = 0;
                        if (newTop < 0) newTop = 0;
                        if (newLeft + element.offsetWidth > canvas.offsetWidth) newLeft = canvas.offsetWidth - element.offsetWidth;
                        if (newTop + element.offsetHeight > canvas.offsetHeight) newTop = canvas.offsetHeight - element.offsetHeight;

                        // Calculate actual Delta applied (incase of boundary hit)
                        const deltaX = newLeft - element.offsetLeft;
                        const deltaY = newTop - element.offsetTop;

                        // Apply move to leader
                        if (alignmentHelperEnabled) {
                            const snapResult = getSnapCoordinates(element.id, newLeft, newTop, element.offsetWidth, element.offsetHeight);
                            
                            // Re-calculate delta if snap happened
                            const snapDeltaX = snapResult.x - element.offsetLeft;
                            const snapDeltaY = snapResult.y - element.offsetTop;
                            
                            element.style.top = `${snapResult.y}px`;
                            element.style.left = `${snapResult.x}px`;
                            updateGuides(snapResult.guides);
                            
                            moveGroupPeers(element.id, snapDeltaX, snapDeltaY);
                        } else {
                            element.style.top = `${newTop}px`;
                            element.style.left = `${newLeft}px`;
                            hideGuides();
                            moveGroupPeers(element.id, deltaX, deltaY);
                        }
                    };
                };
            }

            function moveGroupPeers(leaderId, dx, dy) {
                const groupId = groupMap.get(leaderId);
                if (groupId === undefined) return;

                components.forEach(comp => {
                    if (comp.id !== leaderId && groupMap.get(comp.id) === groupId) {
                        const peerEl = document.getElementById(comp.id);
                        if (peerEl) {
                            // Move peer by exact delta
                            peerEl.style.left = `${peerEl.offsetLeft + dx}px`;
                            peerEl.style.top = `${peerEl.offsetTop + dy}px`;
                        }
                    }
                });
            }

            function makeResizable(element, resizer) {
                if (!resizer) return;
                resizer.addEventListener('mousedown', e => {
                    if (lockedComponents.has(element.id)) return;
                    e.stopPropagation();
                    window.addEventListener('mousemove', resize);
                    window.addEventListener('mouseup', stopResize);
                    
                    function resize(e) {
                        let newWidth = (e.clientX - element.getBoundingClientRect().left);
                        let newHeight = (e.clientY - element.getBoundingClientRect().top);
                        if (newWidth < 20) newWidth = 20;
                        if (newHeight < 20) newHeight = 20;
                        element.style.width = `${newWidth}px`;
                        element.style.height = `${newHeight}px`;
                    }
                    
                    function stopResize() {
                        window.removeEventListener('mousemove', resize);
                        window.removeEventListener('mouseup', stopResize);
                        const component = components.find(c => c.id === element.id);
                        if (component) {
                            component.width = element.offsetWidth;
                            component.height = element.offsetHeight;
                        }
                    }
                });
            }
            
            // --- CONTEXT MENU ACTIONS ---
            contextMenu.addEventListener('click', e => {
                const isSubmenuTrigger = e.target.closest('.submenu-container');
                if(isSubmenuTrigger && !e.target.dataset.action) return;

                const action = e.target.closest('[data-action]')?.dataset.action;
                if (!action || !contextComponentId) {
                    if (!isSubmenuTrigger) contextMenu.classList.add('hidden');
                    return;
                };

                e.preventDefault();
                const clickedComp = components.find(c => c.id === contextComponentId);
                if (!clickedComp) return;

                // Handle Alignment actions first
                if (action.startsWith('align-')) {
                    startAlignmentMode(contextComponentId, action);
                    contextMenu.classList.add('hidden');
                    return;
                }

                switch (action) {
                    case 'bring-forward':
                    case 'send-backward':
                    case 'bring-to-front':
                    case 'send-to-back':
                        const sorted = [...components].sort((a,b) => a.zIndex - b.zIndex);
                        const idx = sorted.findIndex(c => c.id === contextComponentId);
                        if(action === 'bring-forward' && idx < sorted.length - 1) [clickedComp.zIndex, sorted[idx+1].zIndex] = [sorted[idx+1].zIndex, clickedComp.zIndex];
                        if(action === 'send-backward' && idx > 0) [clickedComp.zIndex, sorted[idx-1].zIndex] = [sorted[idx-1].zIndex, clickedComp.zIndex];
                        if(action === 'bring-to-front') clickedComp.zIndex = components.length;
                        if(action === 'send-to-back') clickedComp.zIndex = -1;
                        reorderZIndexes();
                        break;

                    case 'duplicate':
                        duplicateComponent(contextComponentId);
                        break;
                    
                    case 'center-window':
                        if(!lockedComponents.has(clickedComp.id)) {
                            clickedComp.x = (canvas.offsetWidth - clickedComp.width) / 2;
                            clickedComp.y = (canvas.offsetHeight - clickedComp.height) / 2;
                            renderComponent(clickedComp);
                        }
                        break;
                    case 'fit-window':
                        if(!lockedComponents.has(clickedComp.id)) {
                            clickedComp.x = 0; clickedComp.y = 0;
                            clickedComp.width = canvas.offsetWidth; clickedComp.height = canvas.offsetHeight;
                            renderComponent(clickedComp);
                        }
                        break;
                    case 'smart-border':
                        if(!lockedComponents.has(clickedComp.id)) {
                            marginToolPopup.style.display = 'block';
                            let popupX = clickedComp.x + clickedComp.width + 10;
                            let popupY = clickedComp.y;
                            if (popupX + 200 > canvas.offsetWidth) popupX = clickedComp.x - 210;
                            if (popupX < 0) popupX = 10;
                            if (popupY + 80 > canvas.offsetHeight) popupY = canvas.offsetHeight - 90;
                            marginToolPopup.style.left = `${popupX}px`;
                            marginToolPopup.style.top = `${popupY}px`;
                            marginSlider.value = 0;
                            marginValueDisplay.innerText = "0px";
                        }
                        break;

                    case 'lock':
                        toggleGroupLock(contextComponentId, true);
                        break;
                    case 'unlock':
                        toggleGroupLock(contextComponentId, false);
                        break;

                    case 'start-grouping':
                        startGroupingMode(contextComponentId);
                        break;
                    case 'ungroup':
                        const grpId = groupMap.get(contextComponentId);
                        if (grpId !== undefined) {
                            const toRemove = [];
                            groupMap.forEach((v, k) => { if(v === grpId) toRemove.push(k); });
                            toRemove.forEach(k => groupMap.delete(k));
                        }
                        break;
                        
                    case 'start-attachment':
                        if (BASE_COMPONENTS.includes(clickedComp.type) || hybridBases.has(contextComponentId)) {
                            startAttachmentMode(contextComponentId);
                        }
                        break;
                    case 'detach':
                        attachmentMap.delete(contextComponentId);
                        // If detaching a CardView from Panel, remove hybrid status
                        if (hybridBases.has(contextComponentId) && clickedComp.type === 'CardView') {
                            hybridBases.delete(contextComponentId);
                        }
                        break;
                }
                
                if (action !== 'smart-border') {
                    contextMenu.classList.add('hidden');
                }
            });

            // Helper to lock/unlock groups
            function toggleGroupLock(targetId, shouldLock) {
                const groupId = groupMap.get(targetId);
                const idsToUpdate = [];
                if (groupId !== undefined) {
                    groupMap.forEach((gId, cId) => { if (gId === groupId) idsToUpdate.push(cId); });
                } else {
                    idsToUpdate.push(targetId);
                }
                idsToUpdate.forEach(id => {
                    if (shouldLock) lockedComponents.add(id); else lockedComponents.delete(id);
                    const comp = components.find(c => c.id === id);
                    if (comp) renderComponent(comp);
                });
            }

            // --- ALIGNMENT MODE LOGIC ---
            function startAlignmentMode(sourceId, type) {
                if (lockedComponents.has(sourceId)) {
                    alert('Cannot align a locked component.');
                    return;
                }
                alignSourceId = sourceId;
                pendingAlignmentType = type;
                isAlignmentMode = true;
                
                alignmentControl.style.display = 'flex';
                // Highlight selectable targets visually in renderComponent
                renderAllComponents(); 
            }

            cancelAlignmentBtn.addEventListener('click', exitAlignmentMode);

            function exitAlignmentMode() {
                isAlignmentMode = false;
                alignSourceId = null;
                pendingAlignmentType = null;
                alignmentControl.style.display = 'none';
                renderAllComponents();
            }

            function performAlignment(targetId) {
                if (targetId === alignSourceId) return; // Cannot align to self

                const sourceComp = components.find(c => c.id === alignSourceId);
                const targetComp = components.find(c => c.id === targetId);

                if (!sourceComp || !targetComp) {
                    exitAlignmentMode();
                    return;
                }

                let newX = sourceComp.x;
                let newY = sourceComp.y;

                // Calculate new position based on type
                switch (pendingAlignmentType) {
                    // Horizontal
                    case 'align-h-left': newX = targetComp.x; break;
                    case 'align-h-right': newX = targetComp.x + targetComp.width - sourceComp.width; break;
                    case 'align-h-center': newX = targetComp.x + (targetComp.width / 2) - (sourceComp.width / 2); break;
                    
                    // Vertical
                    case 'align-v-top': newY = targetComp.y; break;
                    case 'align-v-bottom': newY = targetComp.y + targetComp.height - sourceComp.height; break;
                    case 'align-v-center': newY = targetComp.y + (targetComp.height / 2) - (sourceComp.height / 2); break;
                }

                // Calculate Delta
                const deltaX = newX - sourceComp.x;
                const deltaY = newY - sourceComp.y;

                // Apply to Source
                sourceComp.x = newX;
                sourceComp.y = newY;
                renderComponent(sourceComp);

                // If source is grouped, move peers by same delta
                moveGroupPeers(sourceComp.id, deltaX, deltaY);

                exitAlignmentMode();
            }

            // --- ATTACHMENT MODE LOGIC ---
            function startAttachmentMode(baseId) {
                isAttachmentMode = true;
                attachmentBaseId = baseId;
                tempAttachmentSelection.clear();
                
                // Show controls
                attachmentControl.style.display = 'flex';
                propertyEditor.classList.add('hidden');
                canvas.classList.add('attachment-mode');
                
                // Visual update for the base
                document.getElementById(baseId)?.classList.add('attachment-base');
            }

            finishAttachmentBtn.addEventListener('click', () => {
                if (attachmentBaseId && tempAttachmentSelection.size > 0) {
                    tempAttachmentSelection.forEach(childId => {
                        attachmentMap.set(childId, attachmentBaseId);
                        // Ensure child zIndex is greater than parent
                        const parent = components.find(c => c.id === attachmentBaseId);
                        const child = components.find(c => c.id === childId);
                        if (parent && child && child.zIndex <= parent.zIndex) {
                            child.zIndex = parent.zIndex + 1;
                        }
                        
                        // If CardView is attached to Panel, it becomes a hybrid
                        if (parent.type === 'Panel' && child.type === 'CardView') {
                            hybridBases.add(childId);
                        }
                        
                        // If a component is attached to a hybrid CardView, the hybrid remains
                        if (hybridBases.has(attachmentBaseId) && CHILD_COMPONENTS.includes(child.type)) {
                            // Hybrid CardView can have children
                        }
                    });
                }
                exitAttachmentMode();
            });

            cancelAttachmentBtn.addEventListener('click', exitAttachmentMode);

            function exitAttachmentMode() {
                isAttachmentMode = false;
                attachmentBaseId = null;
                tempAttachmentSelection.clear();
                attachmentControl.style.display = 'none';
                canvas.classList.remove('attachment-mode');
                renderAllComponents();
            }

            // --- GROUPING FUNCTIONS ---
            function startGroupingMode(initialId) {
                isGroupingMode = true;
                tempGroupSelection.clear();
                tempGroupSelection.add(initialId);
                
                // Show controls
                groupingControl.style.display = 'flex';
                propertyEditor.classList.add('hidden');
                
                // Visual update for the initial one
                document.getElementById(initialId)?.classList.add('group-selecting');
            }

            finishGroupingBtn.addEventListener('click', () => {
                if (tempGroupSelection.size > 1) {
                    const newGroupId = groupIdCounter++;
                    tempGroupSelection.forEach(id => {
                        // Remove from old group if exists
                        groupMap.delete(id);
                        groupMap.set(id, newGroupId);
                        document.getElementById(id)?.classList.remove('group-selecting');
                    });
                } else {
                   tempGroupSelection.forEach(id => document.getElementById(id)?.classList.remove('group-selecting'));
                }
                exitGroupingMode();
            });

            cancelGroupingBtn.addEventListener('click', () => {
                tempGroupSelection.forEach(id => document.getElementById(id)?.classList.remove('group-selecting'));
                exitGroupingMode();
            });

            function exitGroupingMode() {
                isGroupingMode = false;
                tempGroupSelection.clear();
                groupingControl.style.display = 'none';
            }

            // --- LAYER TREE VIEW ---
            layerTreeBtn.addEventListener('click', () => {
                renderLayerTree();
                layerTreeModal.style.display = 'flex';
            });

            closeLayerTree.addEventListener('click', () => {
                layerTreeModal.style.display = 'none';
            });

            applyLayerChanges.addEventListener('click', () => {
                // Apply z-index changes from drag and drop
                const layerItems = layerTreeList.querySelectorAll('.layer-item');
                layerItems.forEach((item, index) => {
                    const compId = item.dataset.id;
                    const comp = components.find(c => c.id === compId);
                    if (comp) {
                        comp.zIndex = index;
                    }
                });
                reorderZIndexes();
                layerTreeModal.style.display = 'none';
            });

            function renderLayerTree() {
                layerTreeList.innerHTML = '';
                
                // Create a map of parent to children
                const childrenMap = new Map();
                components.forEach(comp => {
                    const parentId = attachmentMap.get(comp.id);
                    if (parentId) {
                        if (!childrenMap.has(parentId)) {
                            childrenMap.set(parentId, []);
                        }
                        childrenMap.get(parentId).push(comp);
                    }
                });
                
                // Find root components (no parent or parent not in components)
                const roots = components.filter(comp => {
                    const parentId = attachmentMap.get(comp.id);
                    return !parentId || !components.find(c => c.id === parentId);
                });
                
                // Sort roots by zIndex
                roots.sort((a, b) => a.zIndex - b.zIndex);
                
                roots.forEach(root => {
                    renderLayerItem(root, childrenMap, 0);
                });
                
                // Make items draggable
                makeLayerItemsDraggable();
            }

            function renderLayerItem(component, childrenMap, level) {
                const item = document.createElement('div');
                item.className = 'layer-item';
                item.dataset.id = component.id;
                item.style.marginLeft = `${level * 20}px`;
                
                // Icon based on component type
                let icon = 'widgets';
                if (component.type === 'Button') icon = 'smart_button';
                else if (component.type === 'Label') icon = 'label';
                else if (component.type === 'TextBox') icon = 'text_fields';
                else if (component.type === 'TextArea') icon = 'notes';
                else if (component.type === 'Checkbox') icon = 'check_box';
                else if (component.type === 'RadioGroup') icon = 'radio_button_checked';
                else if (component.type === 'Dropdown') icon = 'arrow_drop_down_circle';
                else if (component.type === 'Slider') icon = 'tune';
                else if (component.type === 'Panel') icon = 'dashboard';
                else if (component.type === 'ProgressBar') icon = 'linear_scale';
                else if (component.type === 'Spinner') icon = 'refresh';
                else if (component.type === 'CardView') icon = 'dashboard';
                else if (component.type === 'ToggleButton') icon = 'toggle_on';
                else if (component.type === 'Image') icon = 'image';
                
                // Show indicators
                let indicators = '';
                if (BASE_COMPONENTS.includes(component.type)) {
                    indicators += ' (Base)';
                }
                if (hybridBases.has(component.id)) {
                    indicators += ' (Hybrid)';
                }
                if (attachmentMap.has(component.id)) {
                    indicators += ' (Child)';
                }
                
                item.innerHTML = `
                    <div class="layer-icon">
                        <span class="material-symbols-outlined text-[16px]">${icon}</span>
                    </div>
                    <div class="flex-1">
                        <div class="font-medium text-sm">${component.id}${indicators}</div>
                        <div class="text-xs text-gray-500">${component.type}</div>
                    </div>
                    <div class="text-xs text-gray-400">z:${component.zIndex}</div>
                `;
                
                layerTreeList.appendChild(item);
                
                // Add click handler
                item.addEventListener('click', (e) => {
                    if (!e.target.closest('.layer-item').classList.contains('dragging')) {
                        layerTreeList.querySelectorAll('.layer-item').forEach(el => el.classList.remove('selected'));
                        item.classList.add('selected');
                        selectComponent(component.id);
                    }
                });
                
                // Render children
                const children = childrenMap.get(component.id) || [];
                children.sort((a, b) => a.zIndex - b.zIndex);
                
                if (children.length > 0) {
                    const childrenContainer = document.createElement('div');
                    childrenContainer.className = 'layer-children';
                    children.forEach(child => {
                        renderLayerItem(child, childrenMap, level + 1);
                    });
                }
            }

            function makeLayerItemsDraggable() {
                let draggedItem = null;
                
                layerTreeList.querySelectorAll('.layer-item').forEach(item => {
                    item.setAttribute('draggable', 'true');
                    
                    item.addEventListener('dragstart', (e) => {
                        draggedItem = item;
                        setTimeout(() => {
                            item.classList.add('dragging');
                        }, 0);
                    });
                    
                    item.addEventListener('dragend', () => {
                        draggedItem.classList.remove('dragging');
                        draggedItem = null;
                        layerTreeList.querySelectorAll('.layer-item').forEach(el => {
                            el.classList.remove('drag-over');
                        });
                    });
                    
                    item.addEventListener('dragover', (e) => {
                        e.preventDefault();
                        const afterElement = getDragAfterElement(layerTreeList, e.clientY);
                        layerTreeList.querySelectorAll('.layer-item').forEach(el => {
                            el.classList.remove('drag-over');
                        });
                        if (afterElement) {
                            afterElement.classList.add('drag-over');
                        }
                    });
                    
                    item.addEventListener('drop', (e) => {
                        e.preventDefault();
                        if (draggedItem && draggedItem !== item) {
                            const afterElement = getDragAfterElement(layerTreeList, e.clientY);
                            if (afterElement) {
                                layerTreeList.insertBefore(draggedItem, afterElement);
                            } else {
                                layerTreeList.appendChild(draggedItem);
                            }
                        }
                    });
                });
            }

            function getDragAfterElement(container, y) {
                const draggableElements = [...container.querySelectorAll('.layer-item:not(.dragging)')];
                
                return draggableElements.reduce((closest, child) => {
                    const box = child.getBoundingClientRect();
                    const offset = y - box.top - box.height / 2;
                    
                    if (offset < 0 && offset > closest.offset) {
                        return { offset: offset, element: child };
                    } else {
                        return closest;
                    }
                }, { offset: Number.NEGATIVE_INFINITY }).element;
            }

            // --- MARGIN TOOL LOGIC ---
            closeMarginTool.addEventListener('click', () => { marginToolPopup.style.display = 'none'; });
            marginSlider.addEventListener('input', (e) => {
                if (!contextComponentId) return;
                const comp = components.find(c => c.id === contextComponentId);
                if (!comp || lockedComponents.has(comp.id)) return;
                const margin = parseInt(e.target.value);
                marginValueDisplay.innerText = `${margin}px`;
                const newW = canvas.offsetWidth - (margin * 2);
                const newH = canvas.offsetHeight - (margin * 2);
                if (newW > 20 && newH > 20) {
                    comp.x = margin; comp.y = margin; comp.width = newW; comp.height = newH;
                    renderComponent(comp);
                }
            });

            function duplicateComponent(id) {
                const originalComp = components.find(c => c.id === id);
                if (!originalComp) return;
                
                // Check if component is in a group
                const originalGroupId = groupMap.get(id);
                
                if (originalGroupId !== undefined) {
                    // Find all components in the same group
                    const groupMembers = [];
                    groupMap.forEach((groupId, compId) => {
                        if (groupId === originalGroupId) {
                            groupMembers.push(compId);
                        }
                    });
                    
                    // Create a new group ID for the duplicated group
                    const newGroupId = groupIdCounter++;
                    
                    // Map to track old IDs to new IDs for maintaining attachments
                    const idMap = new Map();
                    
                    // Duplicate each member of the group
                    groupMembers.forEach(oldId => {
                        const originalMember = components.find(c => c.id === oldId);
                        if (!originalMember) return;
                        
                        const newMember = JSON.parse(JSON.stringify(originalMember));
                        let copyCount = 1;
                        let newId = `${originalMember.id}_copy_${copyCount}`;
                        while (components.some(c => c.id === newId)) { 
                            copyCount++; 
                            newId = `${originalMember.id}_copy_${copyCount}`; 
                        }
                        
                        newMember.id = newId; 
                        newMember.x += 10; 
                        newMember.y += 10; 
                        newMember.zIndex = components.length;
                        
                        // Store the mapping from old ID to new ID
                        idMap.set(oldId, newId);
                        
                        // Add to components array
                        components.push(newMember);
                        
                        // Add to the new group
                        groupMap.set(newId, newGroupId);
                        
                        // Preserve hybrid status
                        if (hybridBases.has(oldId)) {
                            hybridBases.add(newId);
                        }
                        
                        // Preserve locked status
                        if (lockedComponents.has(oldId)) {
                            lockedComponents.add(newId);
                        }
                    });
                    
                    // Now handle attachments for the duplicated group
                    groupMembers.forEach(oldId => {
                        const newId = idMap.get(oldId);
                        if (!newId) return;
                        
                        // Check if the original had a parent attachment
                        const originalParentId = attachmentMap.get(oldId);
                        if (originalParentId) {
                            // If the parent is also in the duplicated group, use the new parent ID
                            const newParentId = idMap.get(originalParentId);
                            if (newParentId) {
                                attachmentMap.set(newId, newParentId);
                            } else {
                                // Parent is outside the group - keep same parent
                                attachmentMap.set(newId, originalParentId);
                            }
                        }
                        
                        // Find children of this component (could be inside or outside the group)
                        attachmentMap.forEach((parent, child) => {
                            if (parent === oldId) {
                                // If child is in the duplicated group, update to new parent
                                const newChildId = idMap.get(child);
                                if (newChildId) {
                                    attachmentMap.set(newChildId, newId);
                                } else {
                                    // Child is outside the group - keep original relationship
                                    // (This might not be ideal, but maintains consistency)
                                }
                            }
                        });
                    });
                    
                } else {
                    // Single component duplication (existing code with some improvements)
                    const newComp = JSON.parse(JSON.stringify(originalComp));
                    let copyCount = 1;
                    let newId = `${originalComp.id}_copy_${copyCount}`;
                    while (components.some(c => c.id === newId)) { 
                        copyCount++; 
                        newId = `${originalComp.id}_copy_${copyCount}`; 
                    }
                    
                    newComp.id = newId; 
                    newComp.x += 10; 
                    newComp.y += 10; 
                    newComp.zIndex = components.length;
                    
                    // If original has children, duplicate them too
                    const originalChildren = [];
                    attachmentMap.forEach((parent, child) => {
                        if (parent === id) {
                            originalChildren.push(child);
                        }
                    });
                    
                    components.push(newComp);
                    
                    // Preserve group membership if any
                    const groupId = groupMap.get(id);
                    if (groupId !== undefined) {
                        groupMap.set(newId, groupId);
                    }
                    
                    // Preserve locked status
                    if (lockedComponents.has(id)) {
                        lockedComponents.add(newId);
                    }
                    
                    // Preserve hybrid status
                    if (hybridBases.has(id)) {
                        hybridBases.add(newId);
                    }
                    
                    // Duplicate children and maintain attachment
                    originalChildren.forEach(childId => {
                        const childComp = components.find(c => c.id === childId);
                        if (childComp) {
                            const newChild = JSON.parse(JSON.stringify(childComp));
                            copyCount = 1;
                            let newChildId = `${childComp.id}_copy_${copyCount}`;
                            while (components.some(c => c.id === newChildId)) { 
                                copyCount++; 
                                newChildId = `${childComp.id}_copy_${copyCount}`; 
                            }
                            
                            newChild.id = newChildId; 
                            newChild.x += 10; 
                            newChild.y += 10; 
                            newChild.zIndex = components.length;
                            components.push(newChild);
                            attachmentMap.set(newChildId, newId);
                            
                            // Preserve group membership of children
                            const childGroupId = groupMap.get(childId);
                            if (childGroupId !== undefined) {
                                groupMap.set(newChildId, childGroupId);
                            }
                            
                            // Preserve hybrid status
                            if (hybridBases.has(childId)) {
                                hybridBases.add(newChildId);
                            }
                            
                            // Preserve locked status
                            if (lockedComponents.has(childId)) {
                                lockedComponents.add(newChildId);
                            }
                        }
                    });
                }
                
                renderAllComponents();
                
                // Select the duplicated component (or first of duplicated group)
                let newId;
                if (originalGroupId !== undefined) {
                    // Select the first component in the duplicated group
                    const groupMembers = Array.from(groupMap.entries())
                        .filter(([_, groupId]) => groupId === groupIdCounter - 1)
                        .map(([compId]) => compId);
                    
                    if (groupMembers.length > 0) {
                        newId = groupMembers[0];
                    } else {
                        newId = `${id}_copy_1`;
                    }
                } else {
                    newId = `${id}_copy_1`;
                }
                
                selectComponent(newId);
            }

            // ... (Live Preview, Save/Load JSON Logic - same as before, but with hybrid support) ...
            function openPreview() {
                previewCanvas.innerHTML = '';
                previewCanvas.style.width = canvas.style.width;
                previewCanvas.style.height = canvas.style.height;

                let dynamicStyles = document.getElementById('dynamic-preview-styles');
                if (dynamicStyles) dynamicStyles.remove();
                dynamicStyles = document.createElement('style');
                dynamicStyles.id = 'dynamic-preview-styles';
                document.head.appendChild(dynamicStyles);

                // Sort components by zIndex for proper rendering
                const sortedComponents = [...components].sort((a, b) => a.zIndex - b.zIndex);
                
                sortedComponents.forEach(comp => {
                    const p = comp.properties;
                    const elWrapper = document.createElement('div');
                    elWrapper.className = 'preview-component';
                    elWrapper.style.left = `${comp.x}px`;
                    elWrapper.style.top = `${comp.y}px`;
                    elWrapper.style.width = `${comp.width}px`;
                    elWrapper.style.height = `${comp.height}px`;
                    elWrapper.style.zIndex = comp.zIndex;

                    let el;
                    switch(comp.type) {
                        case 'Button':
                            el = document.createElement('button');
                            el.textContent = p.text;
                            el.className = 'preview-button';
                            el.style.transition = 'transform 0.1s ease, filter 0.1s ease';
                            el.style.backgroundColor = p.backgroundColor;
                            el.style.color = p.textColor;
                            el.style.fontSize = `${p.fontSize}px`;
                            el.style.fontWeight = p.bold ? 'bold' : 'normal';
                            el.style.borderRadius = `${p.cornerRadius}px`;
                            el.style.border = '1px solid #9ca3af';
                            break;
                        case 'TextBox':
                            el = document.createElement('input');
                            el.type = 'text';
                            el.placeholder = p.hintText;
                            el.value = p.text;
                            el.style.color = p.textColor;
                            el.style.backgroundColor = p.backgroundColor;
                            el.style.fontSize = `${p.fontSize}px`;
                            el.style.fontWeight = p.bold ? 'bold' : 'normal';
                            break;
                        case 'TextArea':
                            el = document.createElement('textarea');
                            el.placeholder = p.hintText;
                            el.value = p.text;
                            el.style.color = p.textColor;
                            el.style.backgroundColor = p.backgroundColor;
                            el.style.fontSize = `${p.fontSize}px`;
                            el.style.fontWeight = p.bold ? 'bold' : 'normal';
                            break;
                        case 'Checkbox':
                            el = document.createElement('div');
                            el.className = 'flex items-center justify-start gap-2';
                            const input = document.createElement('input');
                            input.type = 'checkbox';
                            input.checked = p.checked;
                            const label = document.createElement('label');
                            label.textContent = p.text;
                            label.style.color = p.textColor;
                            label.style.fontSize = `${p.fontSize}px`;
                            label.style.fontWeight = p.bold ? 'bold' : 'normal';
                            el.append(input, label);
                            break;
                        case 'RadioGroup':
                            el = document.createElement('div');
                            el.className = 'flex flex-col items-start justify-center gap-2';
                            const groupLabel = document.createElement('label');
                            groupLabel.textContent = p.label;
                            groupLabel.style.color = p.textColor;
                            groupLabel.style.fontSize = `${p.fontSize}px`;
                            groupLabel.style.fontWeight = p.bold ? 'bold' : 'normal';
                            groupLabel.style.marginBottom = '4px';
                            el.appendChild(groupLabel);
                            p.options.split('\n').forEach(opt => {
                                const optionWrapper = document.createElement('div');
                                optionWrapper.className = 'flex items-center gap-2';
                                const radioInput = document.createElement('input');
                                radioInput.type = 'radio';
                                radioInput.name = comp.id;
                                radioInput.value = opt;
                                radioInput.checked = opt === p.checkedValue;
                                const optionLabel = document.createElement('label');
                                optionLabel.textContent = opt;
                                optionLabel.style.color = p.textColor;
                                optionLabel.style.fontSize = `${p.fontSize}px`;
                                optionLabel.style.fontWeight = p.bold ? 'bold' : 'normal';
                                optionLabel.style.whiteSpace = 'nowrap';
                                optionWrapper.append(radioInput, optionLabel);
                                el.appendChild(optionWrapper);
                            });
                            break;
                        case 'Slider':
                            el = document.createElement('input');
                            el.type = 'range';
                            el.min = p.min;
                            el.max = p.max;
                            el.value = p.value;
                            el.className = `preview-slider-${comp.id}`;
                            el.style.height = '6px';
                            el.style.margin = 'auto 0';

                            const updateSliderStyle = (target) => {
                                const newPercent = ((target.value - p.min) / (p.max - p.min)) * 100;
                                target.style.background = `linear-gradient(to right, ${p.progressColor} 0%, ${p.progressColor} ${newPercent}%, #e5e7eb ${newPercent}%, #e5e7eb 100%)`;
                            };
                            
                            dynamicStyles.innerHTML += `
                                .preview-slider-${comp.id} { -webkit-appearance: none; appearance: none; width: 100%; border-radius: 3px; outline: none; }
                                .preview-slider-${comp.id}::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 18px; height: 18px; background: ${p.buttonColor}; border-radius: 50%; cursor: pointer; border: 2px solid white; box-shadow: 0 1px 3px rgba(0,0,0,0.2); }
                                .preview-slider-${comp.id}::-moz-range-thumb { width: 18px; height: 18px; background: ${p.buttonColor}; border-radius: 50%; cursor: pointer; border: 2px solid white; box-shadow: 0 1px 3px rgba(0,0,0,0.2); }
                            `;
                            
                            el.addEventListener('input', (e) => updateSliderStyle(e.target));
                            setTimeout(() => updateSliderStyle(el), 0);
                            break;
                        case 'Dropdown':
                            el = document.createElement('select');
                            el.className = `preview-dropdown-${comp.id}`;
                            dynamicStyles.innerHTML += `
                                .preview-dropdown-${comp.id} option:hover { background-color: ${p.selectionColor} !important; }
                            `;
                            const options = p.options.split('\n');
                            options.forEach(opt => {
                                const optionEl = document.createElement('option');
                                optionEl.value = opt;
                                optionEl.textContent = opt;
                                el.appendChild(optionEl);
                            });
                            el.style.backgroundColor = p.backgroundColor;
                            el.style.color = p.textColor;
                            el.style.fontSize = `${p.fontSize}px`;
                            el.style.fontWeight = p.bold ? 'bold' : 'normal';
                            break;
                        case 'ToggleButton':
                            el = document.createElement('label');
                            el.className = 'relative inline-flex items-center cursor-pointer';
                            const toggleInput = document.createElement('input');
                            toggleInput.type = 'checkbox';
                            toggleInput.className = 'sr-only peer';
                            toggleInput.checked = p.checked;
                            const toggleDiv = document.createElement('div');
                            toggleDiv.className = "w-11 h-6 bg-gray-200 rounded-full peer peer-focus:ring-4 peer-focus:ring-blue-300 dark:peer-focus:ring-blue-800 dark:bg-gray-700 peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-0.5 after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all dark:border-gray-600";
                            toggleDiv.style.backgroundColor = p.checked ? p.onColor : p.offColor;
                            toggleInput.addEventListener('change', (e) => {
                                toggleDiv.style.backgroundColor = e.target.checked ? p.onColor : p.offColor;
                            });
                            el.append(toggleInput, toggleDiv);
                            break;
                        case 'Spinner':
                            el = document.createElement('div');
                            el.className = 'flex items-center justify-between border border-gray-400 rounded';
                            el.style.backgroundColor = p.backgroundColor || 'white';
                            const minusBtn = document.createElement('button');
                            minusBtn.textContent = '-';
                            minusBtn.className = 'px-2';
                            minusBtn.style.fontSize = `${p.fontSize}px`;
                            minusBtn.style.color = p.textColor;
                            minusBtn.style.fontWeight = p.bold ? 'bold' : 'normal';
                            const valueSpan = document.createElement('span');
                            valueSpan.textContent = p.value;
                            valueSpan.style.color = p.textColor;
                            valueSpan.style.fontSize = `${p.fontSize}px`;
                            valueSpan.style.fontWeight = p.bold ? 'bold' : 'normal';
                            const plusBtn = document.createElement('button');
                            plusBtn.textContent = '+';
                            plusBtn.className = 'px-2';
                            plusBtn.style.fontSize = `${p.fontSize}px`;
                            plusBtn.style.color = p.textColor;
                            plusBtn.style.fontWeight = p.bold ? 'bold' : 'normal';
                            
                            minusBtn.addEventListener('click', () => {
                                let val = parseInt(valueSpan.textContent);
                                if (val > p.min) valueSpan.textContent = val - 1;
                            });
                            plusBtn.addEventListener('click', () => {
                                let val = parseInt(valueSpan.textContent);
                                if (val < p.max) valueSpan.textContent = val + 1;
                            });
                            el.append(minusBtn, valueSpan, plusBtn);
                            break;
                        default:
                            el = document.createElement('div');
                            el.innerHTML = getComponentHTML(comp);
                            const innerEl = el.firstElementChild;
                            innerEl.style.width = '100%';
                            innerEl.style.height = '100%';
                            el = innerEl;
                    }
                    
                    if (el) {
                        elWrapper.appendChild(el);
                        previewCanvas.appendChild(elWrapper);
                    }
                });

                previewModal.style.display = 'flex';
            }

            function closePreview() {
                previewModal.style.display = 'none';
                if (document.fullscreenElement) {
                    document.exitFullscreen();
                }
            }

            function toggleFullScreen() {
                if (!document.fullscreenElement) {
                    previewContent.requestFullscreen().catch(err => {
                        alert(`Error: ${err.message}`);
                    });
                    fullscreenPreviewBtn.textContent = 'Exit Full Screen';
                } else {
                    document.exitFullscreen();
                    fullscreenPreviewBtn.textContent = 'Full Screen';
                }
            }
            
            livePreviewBtn.addEventListener('click', openPreview);
            closePreviewBtn.addEventListener('click', closePreview);
            fullscreenPreviewBtn.addEventListener('click', toggleFullScreen);
            document.addEventListener('fullscreenchange', () => {
                if (!document.fullscreenElement) {
                    fullscreenPreviewBtn.textContent = 'Full Screen';
                }
            });

            saveJsonBtn.addEventListener('click', () => {
                // Sort components by zIndex
                const sortedComponents = [...components].sort((a,b) => a.zIndex - b.zIndex);
                const layout = {
                    canvas: { 
                        width: canvas.offsetWidth, 
                        height: canvas.offsetHeight,
                        title: windowTitleInput.value
                    },
                    components: sortedComponents,
                    groups: Array.from(groupMap.entries()),
                    attachments: Array.from(attachmentMap.entries()),
                    locked: Array.from(lockedComponents),
                    hybrids: Array.from(hybridBases)
                };
                const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(layout, null, 2));
                const a = document.createElement('a');
                a.href = dataStr;
                a.download = "layout.json";
                a.click();
            });

            loadJsonInput.addEventListener('change', (event) => {
                const file = event.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const layout = JSON.parse(e.target.result);
                        loadLayout(layout);
                    } catch (error) {
                        alert("Invalid JSON file.");
                    }
                };
                reader.readAsText(file);
                event.target.value = '';
            });

            function loadLayout(layout) {
                canvas.style.width = `${layout.canvas.width}px`;
                canvas.style.height = `${layout.canvas.height}px`;
                canvasWidthInput.value = layout.canvas.width;
                canvasHeightInput.value = layout.canvas.height;
                windowTitleInput.value = layout.canvas.title || 'My GUI';
                
                canvas.innerHTML = '';
                // Preserve helper elements
                canvas.appendChild(guideX);
                canvas.appendChild(guideY);
                canvas.appendChild(marginToolPopup);
                canvas.appendChild(groupingControl);
                canvas.appendChild(alignmentControl);
                canvas.appendChild(attachmentControl);
                
                // Clear local states on load
                groupMap.clear();
                lockedComponents.clear();
                attachmentMap.clear();
                hybridBases.clear();
                
                components = layout.components;

                // Restore groups
                if (layout.groups) {
                    layout.groups.forEach(([compId, groupId]) => {
                        groupMap.set(compId, groupId);
                    });
                }
                
                // Restore attachments
                if (layout.attachments) {
                    layout.attachments.forEach(([childId, parentId]) => {
                        attachmentMap.set(childId, parentId);
                    });
                }
                
                // Restore locked components
                if (layout.locked) {
                    layout.locked.forEach(compId => {
                        lockedComponents.add(compId);
                    });
                }
                
                // Restore hybrids
                if (layout.hybrids) {
                    layout.hybrids.forEach(compId => {
                        hybridBases.add(compId);
                    });
                }

                const idSet = new Set();
                const duplicateIds = new Set();
                components.forEach((c, index) => {
                    if (c.zIndex === undefined) c.zIndex = index;
                    if (idSet.has(c.id)) duplicateIds.add(c.id);
                    idSet.add(c.id);
                });

                if (duplicateIds.size > 0) {
                    alert(`Warning: Duplicate IDs found: ${Array.from(duplicateIds).join(', ')}.`);
                }
                
                componentIdCounter = components.length
                    ? Math.max(0, ...components.map(c => parseInt(c.id.split('_').pop()) || 0).filter(Number.isFinite)) + 1
                    : 0;
                
                renderAllComponents();
                selectComponent(null);
            }
        });
    </script>

</body>
</html>
